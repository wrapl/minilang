.. include:: <isonum.txt>

.. include:: <isoamsa.txt>

.. include:: <isotech.txt>

slice
=====

.. rst-class:: mini-api

:mini:`meth slice(Arg₁: sequence, ...)`
   *TBD*


:mini:`type slice < sequence`
   A slice of elements.


:mini:`meth slice()`
   *TBD*


:mini:`meth (Arg₁: slice) != (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice) + (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice) < (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice) <= (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice) = (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice) > (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice) >= (Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: slice)[Arg₂: integer]`
   *TBD*


:mini:`meth (Arg₁: slice)[Arg₂: integer, Arg₃: integer]`
   *TBD*


:mini:`meth (Arg₁: slice):bfind(Arg₂: any)`
   *TBD*


:mini:`meth (Arg₁: slice):bfind(Arg₂: any, Arg₃: function)`
   *TBD*


:mini:`meth (Arg₁: slice):capacity`
   *TBD*


:mini:`meth (Arg₁: slice):count`
   *TBD*


:mini:`meth (Arg₁: slice):find(Arg₂: any)`
   *TBD*


:mini:`meth (Arg₁: slice):find(Arg₂: any, Arg₃: function)`
   *TBD*


:mini:`meth (Arg₁: slice):first`
   *TBD*


:mini:`meth (Arg₁: slice):first2`
   *TBD*


:mini:`meth (Arg₁: slice):last`
   *TBD*


:mini:`meth (Arg₁: slice):last2`
   *TBD*


:mini:`meth (Arg₁: slice):length`
   *TBD*


:mini:`meth (Arg₁: slice):offset`
   *TBD*


:mini:`meth (Arg₁: slice):precount`
   *TBD*


:mini:`meth (Arg₁: slice):random`
   *TBD*


:mini:`meth (Arg₁: slice):sort`
   *TBD*


:mini:`meth (Arg₁: slice):sort(Arg₂: function)`
   *TBD*


:mini:`meth (Arg₁: string::buffer):append(Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: string::buffer):append(Arg₂: slice, Arg₃: string)`
   *TBD*


:mini:`type slice::index`
   *TBD*


:mini:`type slice::iter`
   *TBD*


:mini:`type slice::mutable < slice`
   *TBD*


:mini:`meth (Arg₁: slice::mutable)[Arg₂: integer]`
   *TBD*


:mini:`meth (Arg₁: slice::mutable)[Arg₂: integer, Arg₃: integer]`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):cycle`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):delete(Arg₂: integer)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):empty`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):filter(Arg₂: function)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):grow(Arg₂: sequence, ...)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):insert(Arg₂: integer, Arg₃: any)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):permutations`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):permute`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):pop`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):pop(Arg₂: function)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):pull`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):pull(Arg₂: function)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):push(...)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):put(...)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):remove(Arg₂: function)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):reverse`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):shuffle`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):splice`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):splice(Arg₂: integer, Arg₃: integer)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):splice(Arg₂: integer, Arg₃: integer, Arg₄: slice::mutable)`
   *TBD*


:mini:`meth (Arg₁: slice::mutable):splice(Arg₂: integer, Arg₃: slice::mutable)`
   *TBD*


:mini:`type slice::mutable::iter < slice::iter`
   *TBD*


:mini:`type slice::slice`
   *TBD*


:mini:`meth slice(Arg₁: tuple)`
   *TBD*


:mini:`meth (Arg₁: visitor):const(Arg₂: slice::mutable)`
   *TBD*


:mini:`meth (Arg₁: visitor):copy(Arg₂: slice)`
   *TBD*


:mini:`meth (Arg₁: visitor):visit(Arg₂: slice)`
   *TBD*


