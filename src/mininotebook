#!/usr/bin/env -S minilang
import: gtk("gir/Gtk@4.0")
import: gobject("gir/GObject")
import: gio("gir/Gio")
import: source("gir/GtkSource@5")
import: event("event")

gtk::init()

class: cell(:notebook, :state, :widget, :input, :output,
	state is enum("Ready", "Busy", "Done"),
	init is fun(Cell, Notebook) do
		Cell:notebook := Notebook
		Cell:state := cell::state::Ready
		let Box := gtk::Box::new(gtk::Orientation::vertical, 2)
		let Input := Cell:input := source::View::new()
		let Output := Cell:output := gtk::TextView::new()
		Box:append(Input)
		Box:append(Output)
		let Widget := Cell:widget := gtk::Frame::new(nil)
		Widget:set_child(Box)
		Input:connect("notify::has-focus";) do
			print('Focusing on cell\n')
			Notebook:active := Cell
		end
	end
)

class: notebook(:active, :cells, :widget, :box, :compiler, :parser, :queue,
	init is fun(Notebook) do
		Notebook:cells := []
		Notebook:compiler := compiler(globals())
		Notebook:parser := parser()
		Notebook:queue := task::queue(1)
		let Scrolled := Notebook:widget := gtk::ScrolledWindow::new()
		Scrolled:set_child(Notebook:box := gtk::Box::new(gtk::Orientation::vertical, 5))
	end
)

meth :add_cell(Notebook: notebook) do
	let Cell := cell(Notebook)
	Notebook:cells:put(Cell)
	Notebook:box:append(Cell:widget)
	Cell:widget:set_visible(true)
	Cell:input:grab_focus
	ret Cell
end

meth :run_cell(Notebook: notebook) do
	let Cell := Notebook:active or ret
	let N := Notebook:cells:find(Cell)
	let Next := Notebook:cells[N + 1] or Notebook:add_cell
	Next:input:grab_focus
	let Start := gtk::TextIter()
	let End := gtk::TextIter()
	let Input := Cell:input:get_buffer
	Input:get_bounds(Start, End)
	let Text := Cell:input:get_buffer:get_text(Start, End, false)
	let Output := Cell:output:get_buffer
	(Notebook:queue)(;) do
		let Parser := Notebook:parser
		let Compiler := Notebook:compiler
		print('Input = {Text}\n')
		Parser:input(Text)
		let Buffer := string::buffer()
		var Sep := ""
		loop
			let Result := Parser:evaluate(Compiler)
			until Result = compiler::EOI
			Buffer:write(Sep)
			Buffer:write(Result)
			Sep := "\n"
		on Error do
			print(Error)
			Buffer:write(Sep)
			Buffer:write(Error)
			exit
		end
		Parser:reset
		let Result := Buffer:rest
		print('Output = {Result}\n')
		Output:set_text(Result, Result:size)
	on Error do
		print(Error)
	end
end

let Window := gtk::Window::new()

let Header := gtk::HeaderBar::new()

let AddButton := gtk::Button::new_from_icon_name("list-add-symbolic")
let RunButton := gtk::Button::new_from_icon_name("system-run-symbolic")

Header:pack_start(AddButton)
Header:pack_start(RunButton)

let Notebook := notebook()

Window:set_title("Minilang Notebook")
Window:set_titlebar(Header)
Window:set_child(Notebook:widget)
Window:set_visible(true)

AddButton:connect("clicked"; Button) do
	Notebook:add_cell
end

RunButton:connect("clicked"; Button) do
	Notebook:run_cell
end

callcc(0)
